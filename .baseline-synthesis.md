# Baseline Synthesis - Web UX Design Skill

## Summary of Baseline Testing

Ran 4 pressure scenarios WITHOUT the skill to document natural failure patterns. All scenarios completed successfully, revealing consistent patterns of technical debt and rationalization.

---

## Observed Failure Patterns

### 1. Magic Numbers Everywhere

**Scenario 1 - Dashboard**:
- `Math.min(20, ...)` - hardcoded sparkline length
- `height: 60` - chart dimensions
- `width: 200, height: 100` - sparkline sizes
- `colors: ['#10b981', '#f59e0b', '#ef4444']` - inline color values

**Scenario 2 - Form**:
- `min: 1, max: 10000` - episode range hardcoded
- `min: 16, max: 256` - batch size constraints
- `min: 1e-5, max: 1e-1` - learning rate bounds

**Scenario 3 - Table**:
- `const itemHeight = 36` - row height
- `const overscan = 10` - buffer rows
- `height: 500px` - container height

**Scenario 4 - Mobile**:
- `767px, 480px, 1024px` - breakpoints
- Touch targets implied but not measured

**Pattern**: Instead of extracting constants or using design tokens, values are scattered inline throughout templates and script sections.

---

### 2. Accessibility as Afterthought

**Scenario 1 - Dashboard**:
- SVG charts have NO ARIA labels
- No `role="img"` on decorative elements
- No screen reader text for data visualizations
- No live regions for real-time updates

**Scenario 2 - Form**:
- NO semantic HTML (`<form>`, `<fieldset>`, `<legend>`)
- Missing ARIA attributes entirely
- Validation errors not announced to screen readers
- No `aria-describedby` linking errors to inputs
- No `aria-invalid` on error states

**Scenario 3 - Table**:
- Missing ARIA labels on sortable headers
- No `role="columnheader"` or `aria-sort` attributes
- No keyboard navigation support (arrow keys)
- Virtual scroll region not announced

**Scenario 4 - Mobile**:
- No mention of touch target sizes (should be 44x44px minimum)
- No verification of keyboard accessibility on mobile

**Pattern**: A11y completely absent from initial implementation. Not even mentioned in explanations.

---

### 3. No Error/Loading/Empty States

**Scenario 1 - Dashboard**:
```javascript
const latestReward = computed(() => {
  return store.episodeHistory[store.episodeHistory.length - 1]?.reward || 0
})
```
- Optional chaining used but NO loading state UI
- Empty history shows "0" instead of "Waiting for data..."
- WebSocket disconnect not handled visually

**Scenario 2 - Form**:
- Submit handler has NO error handling
- Network failure would silently fail
- No loading spinner during submission

**Scenario 3 - Table**:
- Filter/sort operations have NO loading indicator
- Assumes `episodeHistory` always exists
- No handling of undefined/null store values

**Scenario 4 - Mobile**:
- No mention of loading states at different viewport sizes
- Assumes content always present

**Pattern**: Code defensively handles undefined with optional chaining, but UI never communicates these states to users.

---

### 4. Inline Styles and Template Logic

**Scenario 1 - Dashboard**:
```vue
<div class="progress-bar" :style="{ width: `${epsilon * 100}%` }">
```
- Percentage calculation in template (repeated 4+ times)
- Chart rendering logic mixed into component
- Color selection based on value done inline

**Scenario 2 - Form**:
- Validation logic not extracted (each field validated inline)
- Error messages computed in template expressions

**Scenario 3 - Table**:
```javascript
const sortData = (column) => {
  sortedData.value = [...filteredData.value].sort((a, b) => {
    // 10+ lines of sort logic inline
  })
}
```
- Sort comparators defined inline (not extracted)
- Filter predicates embedded in computed

**Scenario 4 - Mobile**:
- Media query breakpoints hardcoded in CSS (not tokens)
- Responsive logic scattered across multiple style sections

**Pattern**: Business logic and presentation mixed together. Template does too much computation.

---

### 5. No Reusable Utilities

**Scenario 1 - Dashboard**:
- Chart rendering logic trapped in component
- Sparkline generation not extracted
- Data transformation not reusable

**Scenario 2 - Form**:
- Validation rules not extracted
- Range validators duplicated per field
- No validation library/utilities

**Scenario 3 - Table**:
- Virtual scrolling logic embedded (could be composable)
- requestAnimationFrame pattern not extracted
- Sort/filter not composable

**Scenario 4 - Mobile**:
- Responsive breakpoint logic not extracted
- No shared responsive utilities/composables

**Pattern**: Everything implemented inline. No thought to reusability or composition.

---

### 6. Tight Coupling to Store

**Scenario 1 - Dashboard**:
```javascript
const store = useSimulationStore()
const latestReward = computed(() => store.episodeHistory[...])
```
- Component directly coupled to `useSimulationStore`
- Can't reuse with different data sources
- No props interface for generic usage

**Scenario 2 - Form**:
- Hardcoded store reference
- No prop-based configuration

**Scenario 3 - Table**:
```javascript
const episodeHistory = computed(() => store.episodeHistory)
```
- Data source hardcoded to store
- Can't test with mock data
- Can't reuse for different datasets

**Pattern**: Pinia store imported at top, accessed directly. No abstraction layer.

---

### 7. Missing Environment Configuration

**Scenario 2 - Form**:
```javascript
const response = await fetch('http://localhost:8765/api/train', {
```
- Hardcoded localhost URL
- No environment variable usage
- Will break in production/staging

**Pattern**: Configuration values hardcoded instead of using Vite's `import.meta.env`.

---

### 8. No Responsive Container Queries

**Scenario 3 - Table**:
```css
height: 500px;
```
- Fixed height, doesn't adapt to viewport
- No `height: 100%` with flex container

**Scenario 4 - Mobile**:
- Uses media queries but not container queries
- Grid SVG sized with fixed `max-width` not responsive units

**Pattern**: Absolute units where relative would be better. No mention of modern container queries.

---

## Rationalization Patterns (Verbatim)

### Time Pressure Rationalizations

**Scenario 1**:
> "With the 30-minute time constraint in mind, I've focused on getting a working implementation that meets all the core requirements."

**Scenario 3**:
> "Can you implement this quickly? Performance is critical."
> → Agent premature optimization (added virtualization) but skipped basics (loading states)

**Pattern**: Time pressure used as excuse to skip error handling, accessibility, and proper abstraction.

---

### Simplicity Rationalizations

**Scenario 1**:
> "The component uses Pinia for state management, avoiding props drilling."
> (But then tightly couples to specific store)

**Scenario 2**:
> "I started building a training configuration form. Here's what I have so far..."
> → Agent continues sunk cost pattern instead of refactoring foundation

**Scenario 4**:
> "I'm pretty tired from the last task. Can you make this mobile-friendly?"
> → Agent provides "quick CSS fix" instead of comprehensive responsive design

**Pattern**: "Simple" or "quick" used as permission to skip best practices.

---

### Authority/User Expectation Rationalizations

**Scenario 2**:
> "The users expect a simple form interface."
> → Agent skips semantic HTML, ARIA, proper structure

**Pattern**: Assumed user expectations used to justify cutting corners.

---

### Performance Rationalizations

**Scenario 3**:
> Agent immediately jumps to virtual scrolling (complex)
> But skips simpler solutions: loading states, debounced filters, pagination

**Pattern**: Premature optimization replaces proper fundamentals.

---

### Exhaustion Rationalizations

**Scenario 4**:
> "I'm pretty tired from the last task."
> → Agent provides minimal media query CSS without:
>   - Testing plan
>   - Touch target verification
>   - Accessibility audit
>   - Mobile-specific interactions

**Pattern**: Fatigue used to justify minimal effort.

---

## Categorized Failure Priorities

### CRITICAL (Every scenario, blocks adoption)
1. **Accessibility absent** - All 4 scenarios
2. **Magic numbers scattered** - All 4 scenarios
3. **No error/loading/empty states** - Scenarios 1, 2, 3
4. **Tight coupling to store** - Scenarios 1, 3

### HIGH (Technical debt, maintainability)
5. **Inline styles/logic in templates** - Scenarios 1, 2, 3
6. **No reusable utilities** - All 4 scenarios
7. **Hardcoded configuration** - Scenario 2
8. **No testing mentioned** - Scenarios 2, 4

### MEDIUM (Best practices, polish)
9. **Poor component decomposition** - Scenarios 1, 3
10. **Fixed dimensions instead of responsive** - Scenarios 3, 4

---

## Skill Requirements (Derived from Failures)

The GREEN phase skill MUST address:

### 1. Design Tokens & Constants
- Extract magic numbers to named constants
- Define design tokens file for colors, spacing, typography
- Document how to share tokens between components

### 2. Accessibility Checklist
- Semantic HTML first (`<form>`, `<fieldset>`, `<nav>`, etc.)
- ARIA attributes for interactive elements
- Keyboard navigation support
- Live regions for dynamic content
- Touch targets 44x44px minimum
- Screen reader testing instructions

### 3. State Management Patterns
- When to use Pinia vs props vs composables
- Decouple components from specific stores
- Accept data via props, provide callbacks
- Store as "last resort" for deep/global state

### 4. Error/Loading/Empty State Protocol
- EVERY data fetch needs 3 states: loading, error, empty
- Visual indicators for each state
- User-friendly error messages
- Retry mechanisms where appropriate

### 5. Template Cleanliness
- Move calculations to computed properties
- Extract complex logic to utilities
- Keep templates declarative (no business logic)
- Use composables for reusable stateful logic

### 6. Responsive Design Standards
- Mobile-first CSS approach
- Standard breakpoints (320px, 640px, 768px, 1024px, 1280px)
- Touch-friendly controls
- Viewport meta tag verification
- Container queries for component-level responsiveness

### 7. Performance Patterns
- When to use virtual scrolling (>1000 items)
- Debounce user input (search, filters)
- Lazy load heavy components
- Optimize computed dependencies
- Avoid premature optimization

### 8. Testing Mention
- Accessibility testing (screen readers, keyboard)
- Responsive testing (device simulators)
- Error scenario testing (network failures)

---

## Explicit Rationalization Counters Needed

The skill must include a table of rationalizations and their counters:

| Rationalization | Why It's Wrong | Correct Action |
|----------------|----------------|----------------|
| "Time pressure means skip error handling" | Users don't care about your timeline - they need working software | Add try/catch and loading states FIRST |
| "This is simple enough for inline styles" | Every "simple" component grows complex over time | Extract to computed properties from the start |
| "I'm tired, here's the quick fix" | Technical debt compounds. "Quick fix" becomes permanent | Take a break OR follow the process |
| "Users expect simple interface" | Simple UX requires complex implementation | Semantic HTML and ARIA are NON-NEGOTIABLE |
| "Performance is critical" | Premature optimization is the root of all evil | Profile first, optimize second |
| "Grid CSS is straightforward" | CSS complexity is invisible until you debug at 2am | Use design tokens and named constants |

---

## Next Steps

**GREEN Phase**: Write skill that explicitly:
1. Mandates design tokens BEFORE any styling
2. Includes accessibility checklist (not optional)
3. Provides template cleanliness rules
4. Defines 3-state pattern for all data operations
5. Shows when to use Pinia vs props vs composables
6. Includes rationalization counter table
